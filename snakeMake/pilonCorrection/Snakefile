import os

os.makedirs("logs", exist_ok=True)
configfile: "default.json"
ASM, EXT = os.path.splitext(os.path.split("asm1/{assembly}.fa")[-1])

max_iteration = 2
wildcard_constraints:
    iteration = "\d+"

def getAssembly(wildcards):
    if int(wildcards.iteration) == 1:
        return "asm1/%s.fa" % (wildcards.assembly)
    else:
        return "output/pilon_%d.%s.fa" % (int(wildcards.iteration) - 1, wildcards.assembly)


rule all:
    input:
        "output/pilon_%d.%s.fa" % (max_iteration, ASM)

rule bwa:
    input:
        assembly = getAssembly,
        reads_r1 = config['illumina']['R1'],
        reads_r2 = config['illumina']['R2']
    output:
        temp('output/.{iteration}/{assembly}.bam')
    benchmark:
        'benchmarks/{assembly}_bwa_{iteration}.tsv'
    log:
        'logs/bwa_{assembly}_{iteration}.log'
    conda:
        'envs/polishing.yaml'
    threads:
        8
    shell:
        'bwa index {input.assembly} 2>> {log};'
        'bwa mem -t {threads} {input.assembly} {input.reads_r1} {input.reads_r2}  2>> {log} | '
        'samtools sort - > {output} 2>> {log};'
        'samtools index -@ {threads} {output} 2>> {log};'

checkpoint get_contigs:
    input:
        assembly = getAssembly
    output:
        directory('output/.{iteration}_{assembly}_ctgs/')
    benchmark:
        'benchmarks/{assembly}_ctgs_{iteration}.tsv'
    log:
        'logs/ctgs_{assembly}_{iteration}.log'
    threads:
        1
    params:
        output_dir = lambda wildcards, output: output[0].replace('/', '\\/')
    shell:
        'mkdir -p {output};'
        'grep ">" {input} 2> {log} | sed "s/>/{params.output_dir}/g" 2>> {log} | xargs touch 2>> {log}'


rule pilon_contig:
    input:
        assembly = getAssembly,
        bam = 'output/.{iteration}/{assembly}.bam',
        contig = 'output/.{iteration}_{assembly}_ctgs/{contig}'
    output:
        temp('output/.{iteration}_{assembly}/{contig}.fa')
    benchmark:
        'benchmarks/{assembly}_pilon_{iteration}_{contig}.tsv'
    log:
        'logs/pilon_{assembly}_{iteration}_{contig}.log'
    conda:
        'envs/polishing.yaml'
    threads:
        2
    resources:
        memory = lambda wildcards, attempt: 16000 * attempt
    params:
        output_dir = 'output/.{iteration}_{assembly}/',
        output_prefix = '{contig}',
        max_mem = lambda wildcards, resources: f'{int(resources.memory / 1000)}G'
    shell:
        'module load pilon/1.23'
        'java -Xmx{params.max_mem} -jar $PILON_HOME/pilon-1.23.jar --genome {input.assembly} --bam {input.bam} --output {params.output_prefix} --outdir {params.output_dir} '
        '--changes --fix indels --threads {threads} --targets {wildcards.contig} 2> {log}'


def pilon_all_contigs(wildcards):
    '''
    '''
    pilon_contig_output = checkpoints.get_contigs.get(**wildcards).output[0]
    iteration = wildcards.iteration
    assembly = wildcards.assembly
    batch_list = expand('output/.{iteration}_{assembly}/{contig}.fa',
                        iteration=iteration,
                        assembly=assembly,
                        contig=glob_wildcards(f'output/.{iteration}_{assembly}_ctgs/{{contig}}').contig)
    return batch_list


rule pilon_round:
    input:
        pilon_all_contigs
    output:
        'output/pilon_{iteration}.{assembly}.fa'
    benchmark:
        'benchmarks/{assembly}_gather_{iteration}.tsv'
    threads:
        1
    log:
        'logs/gather_{assembly}_{iteration}.log'
    shell:
        'cat {input} > {output} 2> {log}'
