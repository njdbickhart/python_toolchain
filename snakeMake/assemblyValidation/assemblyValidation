import os
import subprocess as sp
import itertools
from subprocess import PIPE, STDOUT
import pysam

shell.executable("/usr/bin/bash")

configfile : "default.json"

wildcard_constraints:
    lane = "(1|2)"

localrules: organize

os.makedirs("fastas", exist_ok=True)
os.makedirs("logs", exist_ok=True)
os.makedirs("mapped", exist_ok=True)



finalSummary = ["final/summary_table.tab"]
pcombis = []
if len(config["assembly"].keys()) > 1:
    finalSummary.extend(["final/combined_frc_plot.pdf", "final/combined_ngx_plot.pdf"])
    # Adding iterations of dotplots
    pcombis = [c[0] + "_" + c[1] for c in list(itertools.combinations(config["assembly"].keys(), 2))]
    finalSummary.extend(expand("final/plot{C}.png", C=pcombis))
    finalSummary.extend(expand("final/vars{C}.log_all_sizes.pdf", C=pcombis))

rule all:
    input:
        finalSummary,
        expand("final/ideogram_errors.{asm}.pdf", asm = config["assembly"].keys()),
        expand("final/ideogram_upperq_error_windows.{asm}.bed", asm = config["assembly"].keys()),
        expand("merqury/{asm}/{asm}.spectra-asm.{postfix}.pdf", asm = config["assembly"].keys(), postfix=["fl", "ln", "st"])



rule organize:
    input:
        lambda wildcards: config["assembly"][wildcards.asm]
    output:
        temp("fastas/{asm}.fa")
    run:
        cmd = ["ln", "-s", input[0], output[0]]
        print(cmd)
        sp.call(cmd)

rule bwa_index:
    input:
        "fastas/{asm}.fa"
    output:
        "fastas/{asm}.fa.amb",
        "fastas/{asm}.fa.ann",
        "fastas/{asm}.fa.bwt",
        "fastas/{asm}.fa.pac",
        "fastas/{asm}.fa.sa",
        "fastas/{asm}.fa.fai"
    log:
        "logs/{asm}/{asm}.indexing.log"
    conda:
        "envs/base.yaml"
    shell:
        """
        bwa index {input} 2> {log}
        samtools faidx {input} 2> {log}
        """

rule align_reads:
    input:
        fq1 = lambda wildcards: config["samples"][wildcards.sample][0],
        fq2 = lambda wildcards: config["samples"][wildcards.sample][1],
        fasta = "fastas/{asm}.fa",
        amb = "fastas/{asm}.fa.amb",
        ann = "fastas/{asm}.fa.ann",
        bwt = "fastas/{asm}.fa.bwt",
        pac = "fastas/{asm}.fa.pac",
        sa = "fastas/{asm}.fa.sa",
        fai = "fastas/{asm}.fa.fai"
    output:
        temp("mapped/{asm}/{sample}.bam")
    log:
        "logs/{asm}/{sample}_bwa.log"
    threads: 8
    conda:
        "envs/base.yaml"
    shell:
        """
        bwa mem -R '@RG\\tID:{wildcards.sample}\\tSM:{wildcards.sample}\\tPL:ILLUMINA' -t {threads} -M {input.fasta} {input.fq1} {input.fq2} | samtools sort -o {output}  - >> {log} 2>&1
        samtools index {output}
        """

rule merge_bams:
    input:
        expand("mapped/{{asm}}/{sample}.bam", sample=config["samples"])
    output:
        "mapped/{asm}/merged.bam",
        "mapped/{asm}/merged.bam.bai"
    threads: 8
    conda:
        "envs/base.yaml"
    shell:
        """
        samtools merge -@ {threads} {output[0]} {input}
        samtools index {output[0]}
        """


rule freebayes:
    input:
        ref=lambda wildcards: config["assembly"][wildcards.asm],
        samples="mapped/{asm}/merged.bam",
        indexes="mapped/{asm}/merged.bam.bai"
    output:
        "calls/{asm}/merged_freebayes.vcf"
    log:
        "logs/{asm}/freebayes.log"
    conda:
        "envs/freebayes.yaml"
    params:
        extra="-C 2 -0 -O -q 20 -z 0.10 -E 0 -X -u -p 2 -F 0.75",
        chunksize=1000000
    threads: 10
    script:
        "scripts/freebayes_lift.py"



rule frc_align:
    input:
        ref=lambda wildcards: config["assembly"][wildcards.asm],
        samples="mapped/{asm}/merged.bam"
    output:
        features="calls/{asm}/merged_frc.txt_Features.txt",
        frc="calls/{asm}/merged_frc.txt_FRC.txt"
    params:
        outprefix="calls/{asm}/merged_frc.txt"
    shell:
        """
        module load frc_align
        FRC --pe-sam {input.samples} --output {params.outprefix}
        """

rule lumpy:
    input:
        samples="mapped/{asm}/merged.bam"
    output:
        "calls/{asm}/merged_lumpy.vcf"
    conda:
        "envs/lumpy.yaml"
    log:
        "logs/{asm}/lumpy.log"
    shell:
        """
        lumpyexpress -B {input.samples} -o {output} -v 2> {log}
        """

rule samtools_depth:
    input:
        samples="mapped/{asm}/merged.bam"
    output:
        samdepth="calls/{asm}/merged_depth.txt"
    conda:
        "envs/depth.yaml"
    params:
        threshold = 3
    script:
        "scripts/depth_estimate.py"

rule qv_estimate:
    input:
        vcf="calls/{asm}/merged_freebayes.vcf",
        depth="calls/{asm}/merged_depth.txt"
    output:
        "calls/{asm}/{asm}.qv_value.txt"
    shell:
        """
        bash {workflow.basedir}/scripts/qv_estimate.sh {input.depth} {input.vcf} {output[0]}
        """


def getFlatFastqList(wildcards, config):
    data = list()
    for i in range(2):
        data.append(config["samples"][wildcards.sample][i])
    return data

rule meryl_hapmer:
    input:
        lambda wildcards : getFlatFastqList(wildcards, config)
    output:
        directory("mapped/{sample}_1.meryl"),
        directory("mapped/{sample}_2.meryl")
    threads: 24
    params:
        k = 21,
        extra = "threads=24 memory=48"
    shell:
        """
        module load merqury/1.0
        meryl k={params.k} count output {output[0]} {params.extra} {input[0]}
        meryl k={params.k} count output {output[1]} {params.extra} {input[1]}
        """

rule meryl_merge:
    input:
        expand("mapped/{sample}_{lane}.meryl", sample=config["samples"], lane=["1", "2"])
    output:
        directory("mapped/meryl_db.meryl"),
    threads: 10
    params:
        extra = "cpus=10 memory=48g"
    shell:
        """
        module load merqury/1.0
        meryl union-sum output {output} {input}
        """

#rule run_sample_merqury:
#    input:
#        mdb = expand("mapped/{{sample}}_{lane}.meryl", lane=[1,2]),
#        fasta = lambda wildcards: config["assembly"][wildcards.asm]
#    output:
#        merged = temp("mapped/{sample}_merged.{asm}.meryl"),
#        dist_only = "merqury/{asm}/{sample}.dist_only.hist",
#        qv = "merqury/{asm}/{sample}.qv",
#        spectraasm = "merqury/{asm}/{sample}.spectra-asm.hist",
#        f1 = "merqury/{asm}/{sample}.spectra-asm.fl.pdf",
#        ln = "merqury/{asm}/{sample}.spectra-asm.ln.pdf",
#        st = "merqury/{asm}/{sample}.spectra-asm.st.pdf",
#        complete = "merqury/{asm}/{sample}.completeness.stats"
#    params:
#        outbase = "{sample}",
#        asmbase = "{asm}",
#        pdfbase = "{sample}.spectra-asm"
#    threads:
#        20
#    shell:
#        """
#        module load merqury/1.0
#        bash {workflow.basedir}/scripts/spectra-cn.revised.sh {input.mdb} {input.fasta} {params.asmbase} {params.outbase}
#        mv {params.outbase}.* ./merqury/{params.asmbase}/
#        /software/7/apps/merqury/1.0/plot/plot_spectra_cn.R -f {output.spectraasm} -o {params.pdfbase} -z {output.dist_only} --pdf
#        mv {params.pdfbase}.*.pdf ./merqury/{params.asmbase}/
#        """

rule run_merqury:
    input:
        mdb = "mapped/meryl_db.meryl",
        fasta = lambda wildcards: config["assembly"][wildcards.asm]
    output:
        dist_only = "merqury/{asm}/{asm}.dist_only.hist",
        qv = "merqury/{asm}/{asm}.qv",
        spectraasm = "merqury/{asm}/{asm}.spectra-asm.hist",
        f1 = "merqury/{asm}/{asm}.spectra-asm.fl.pdf",
        ln = "merqury/{asm}/{asm}.spectra-asm.ln.pdf",
        st = "merqury/{asm}/{asm}.spectra-asm.st.pdf",
        complete = "merqury/{asm}/{asm}.completeness.stats"
    params:
        outbase = "{asm}",
        pdfbase = "{asm}.spectra-asm"
    threads: 20
    shell:
        """
        module load merqury/1.0
        bash {workflow.basedir}/scripts/spectra-cn.revised.sh {input.mdb} {input.fasta} {params.outbase} {params.outbase}
        mv {params.outbase}.* ./merqury/{params.outbase}/
        /software/7/apps/merqury/1.0/plot/plot_spectra_cn.R -f {output.spectraasm} -o {params.pdfbase} -z {output.dist_only} --pdf
        mv {params.pdfbase}.*.pdf ./merqury/{params.outbase}/
        """

rule download_busco:
    output:
        directory("busco_downloads/lineages/{}".format(config["buscoLineage"]))
    log:
        "logs/download_busco.log"
    conda:
        "envs/busco.yaml"
    params:
        lineage = config["buscoLineage"]
    shell:
        """
        python {workflow.basedir}/scripts/downloadBuscoLineage.py {params.lineage}
        """

rule run_busco:
    input:
        "busco_downloads/lineages/{}".format(config["buscoLineage"]),
        "fastas/{asm}.fa"
    output:
        "busco/{asm}/busco_summary.txt",
    log:
        "logs/{asm}/run_busco.log"
    threads: 40
    conda:
        "envs/busco.yaml"
    params:
        mode="genome",
        lineage_path=config["buscoLineage"],
        asm = lambda wildcards: wildcards.asm,
        # optional parameters
        extra=""
    script:
        "scripts/busco_lift.py"

rule assembly_stats:
    input:
        "fastas/{asm}.fa"
    output:
        "mapped/{asm}/stats.tab"
    conda:
        "envs/base.yaml"
    script:
        "scripts/calcFastaSumStats.py"

rule summary_table:
    input:
        stats = expand("mapped/{asm}/stats.tab", asm=config["assembly"].keys()),
        merqv = expand("merqury/{asm}/{asm}.qv", asm=config["assembly"].keys()),
        complete = expand("merqury/{asm}/{asm}.completeness.stats", asm=config["assembly"].keys()),
        busco = expand("busco/{asm}/busco_summary.txt", asm=config["assembly"].keys()),
        snpqv = expand("calls/{asm}/{asm}.qv_value.txt", asm=config["assembly"].keys()),
        bams=expand("mapped/{asm}/merged.bam", asm=config["assembly"].keys()),
        features=expand("calls/{asm}/merged_frc.txt_Features.txt", asm=config["assembly"].keys()),
        lumpy = expand("calls/{asm}/merged_lumpy.vcf", asm=config["assembly"].keys())
    output:
        table = "final/summary_table.tab"
    params:
        asms=list(config["assembly"].keys())
    script:
        "scripts/summary_table.py"

rule ideogram_plot:
    input:
        features="calls/{asm}/merged_frc.txt_Features.txt",
        bams="mapped/{asm}/merged.bam"
    output:
        ideogram="final/ideogram_errors.{asm}.pdf",
        bed="final/ideogram_upperq_error_windows.{asm}.bed"
    params:
        chrthresh = 30
    conda:
        "envs/base.yaml"
    shell:
        'python {workflow.basedir}/scripts/ideogram_feature_plot.py -f {input.features}'
        ' -b {input.bams} -o {output.ideogram} -e {output.bed} -t {params.chrthresh}'

rule move_kplots:
    input:
        st = "merqury/{asm}/{asm}.spectra-asm.st.pdf"
    output:
        final = "final/{asm}.spectra-asm.st.pdf"
    shell:
        """
        cp {input.st} {output.final}
        """

def getAssemblyList(wildcards):
    return [v for k, v in config["assembly"].items()]

# Begin comparative plots
if len(config["assembly"].keys()) > 1:
    rule plot_frc:
        input:
            expand("calls/{asm}/merged_frc.txt_FRC.txt", asm=config["assembly"].keys())
        output:
            plot = "final/combined_frc_plot.pdf"
        conda:
            "envs/base.yaml"
        params:
            asms=list(config["assembly"].keys())
        script:
            "scripts/asm_frc_plot.py"

    rule ngx_plot:
        input:
            asms = expand("fastas/{asm}.fa", asm=config["assembly"].keys()),
            fais = expand("fastas/{asm}.fa.fai", asm=config["assembly"].keys())
        output:
            plot = "final/combined_ngx_plot.pdf"
        conda:
            "envs/base.yaml"
        params:
            asms=list(config["assembly"].keys())
        script:
            "scripts/asm_ngx_plot.py"



    rule minimap_align:
        input:
            first = "fastas/{first}.fa",
            second = "fastas/{second}.fa"
        output:
            "mapped/map{first}_{second}.paf"
        conda:
            "envs/dotplotly.yaml"
        threads:
            8
        shell:
            """
            minimap2 -x asm10 -t {threads} {input.first} {input.second} > {output}
            """

    rule dotplot:
        input:
            "mapped/map{C}.paf"
        output:
            "final/plot{C}.png"
        conda:
            "envs/dotplotly.yaml"
        params:
            prefix = lambda wildcards : wildcards.C
        shell:
            """
            Rscript {workflow.basedir}/scripts/pafDotPlotly.R -i {input} -o {params.prefix} -v -l -x -s
            mv {params.prefix}.png {output}
            """

    rule variant_sizes:
        input:
            "mapped/map{C}.paf"
        output:
            "calls/vars{C}.paf"
        conda:
            "envs/base.yaml"
        params:
            max = 1000000,
            qdist = 1000000,
            narrow = 50
        shell:
            """
            python {workflow.basedir}/scripts/betweenAlignmentVariants.py -a {params.max} -q {params.qdist} -n {params.narrow} -f {input} -o {output}
            """

    rule variant_size_histos:
        input:
            "calls/vars{C}.paf"
        output:
            "final/vars{C}.log_all_sizes.pdf",
            "final/vars{C}.75-1000.pdf",
            "final/vars{C}.1000-500000.pdf"
        params:
            prefix = lambda wildcards : "vars" + wildcards.C,
            min = 75,
            max = 500000,
            extra = "-v"
        conda:
            "envs/dotplotly.yaml"
        shell:
            """
            Rscript {workflow.basedir}/scripts/asm_variant_histos.R -i {input} -o {params.prefix} -q {params.min} -m {params.max} {params.extra}
            """
